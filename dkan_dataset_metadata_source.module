<?php
/**
 * @file
 * Code for the DKAN Dataset Metadata Source feature.
 */

include_once 'dkan_dataset_metadata_source.features.inc';
include_once 'dkan_dataset_metadata_source.theme.inc';

/**
 * Implements hook_entity_info_alter().
 */
function dkan_dataset_metadata_source_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['dataset_full'] = array(
    'label' => t('Dataset Page'),
    'custom settings' => TRUE,
  );
}

/**
 * Implements hook_libraries_info().
 */
function dkan_dataset_metadata_source_libraries_info() {
  $libraries= array();
  $libname = 'json-schema';

  // Check library existance before adding it's declaration.
  if (($library = libraries_detect($libname)) && !empty($library['installed'])) {
    $libraries[$libname] = array(
      'name' => 'Justinrainbow JSON-Schema',
      'vendor url' => 'https://github.com/justinrainbow/json-schema.git',
      'download url' => 'https://github.com/justinrainbow/json-schema/tree/master/src/JsonSchema',
      'version' => '1.3.7',
      'files' => array(
        'php' => array(
          'vendor/autoload.php',
        ),
      ),
    );
  }

  return $libraries;
}

/**
 * Implements hook_menu().
 */
function dkan_dataset_metadata_source_menu() {
  $items = array();
  $items['node/%node/metadata'] = array(
    'title' => 'Add Metadata',
    'page callback' => 'dkan_dataset_metadata_source_add_metadata',
    'page arguments' => array(1),
    'access callback' => 'dkan_dataset_metadata_source_add_metadata_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}


/**
 * Access callback for 'Add Metadata' tab.
 */
function dkan_dataset_metadata_source_add_metadata_access($node) {
  if ($node->type != 'dataset') {
    return FALSE;
  }
  elseif (node_hook($node->type, 'form') && node_access('create', $node->type)) {
    return TRUE;
  }
  else {
   return FALSE;
  }
}


/**
 * Callback for 'Add Resouce' tab.
 */
function dkan_dataset_metadata_source_add_metadata($node) {
  drupal_goto('node/add/metadata', array('query' => array('dataset' => $node->nid)));
}

/**
 * Implements hook_form_alter().
 */
function dkan_dataset_metadata_source_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'metadata_node_form') {
    if ($query = drupal_get_query_parameters()) {
      $field_dataset_ref_langcode = dkan_dataset_form_field_language($form, 'field_dataset_metadata_ref');
      if (isset($query['dataset'])) {
        if ($dataset = node_load($query['dataset'])) {
          $form['field_dataset_metadata_ref'][$field_dataset_ref_langcode][0]['target_id']['#default_value'] = "$dataset->title ($dataset->nid)";
        }
        $form['actions']['submit']['#submit'][] = 'dkan_dataset_metadata_metadata_node_form_submit';
      }
    }
  }
  $form['#attached']['js'][] = drupal_get_path('module', 'dkan_dataset_metadata_source') . '/dkan_dataset_metadata_source.js';
}

function dkan_dataset_metadata_metadata_node_form_submit($form, &$form_state) {
  if ($query = drupal_get_query_parameters()) {
    if (isset($query['dataset'])) {
      $form_state['redirect'] = 'node/' . $query['dataset'];
    }
  }
}

/**
 * Implements hook_node_view().
 */
function dkan_dataset_metadata_source_node_view($node, $view_mode, $langcode) {
  if ($view_mode == 'full' && $node->type == 'dataset') {
    $path = array(drupal_get_path('module', 'dkan_dataset_metadata_source') . '/dkan_dataset_metadata_source.css');

    $node->content['metadata_sources'] = array(
      '#theme' => 'dkan_dataset_metadata_source_view',
      '#node' => $node,
      '#enabled' => TRUE,
      '#prefix' => '<div id="metadata-sources">',
      '#suffix' => '</div>',
      '#view_mode' => $view_mode,
      '#weight' => 8,
      '#attached' => array(
        'css' => $path
      ),
    );
  }
}

/**
 * Returns configuration for harvest sources.
 */
function dkan_dataset_metadata_source_taxonomy_fixtures_sources_definition() {
  $modules = module_implements('metadata_taxonomy_sources');
  $subscribed_values = array();
  foreach ($modules as $module) {
    $function = $module . '_metadata_taxonomy_sources';
    $values = $function();
    foreach ($values as $key => $value) {
      // Make sure other module didn't provide the same source.
      if (!isset($subscribed_values[$key])) {
        $subscribed_values[$key] = $value;
      }
    }
  }
  return $subscribed_values;
}

/**
 * Implements hook_taxonomy_fixtures_vocabulary().
 */
function dkan_dataset_metadata_source_taxonomy_fixtures_vocabulary() {
  return dkan_dataset_metadata_source_taxonomy_fixtures_sources_definition();
}

/**
 * Implement hook_field_attach_validate().
 */
function dkan_dataset_metadata_source_field_attach_validate($entity_type, $entity, &$errors) {
  if ($entity_type == 'node' && $entity->type == 'metadata') {
    // Validate the field_metadata_json.
    dkan_dataset_metadata_source_field_attach_validate_field_metadata_json($entity_type, $entity, $errors);
  }
}

/**
 * Helper function to validate field_metadata_json field on metadata node.
 */
function dkan_dataset_metadata_source_field_attach_validate_field_metadata_json($entity_type, $entity, &$errors) {
  // JSON Metadata validation.
  $entity_mw = entity_metadata_wrapper('node', $entity);
  $field_name = 'field_metadata_json';
  $langcode = LANGUAGE_NONE;
  $delta = 0;

  // If The "field_metadata_json" is empty it may mean that the user is fill
  // other field. Move on nothing to validate here.
  $json = $entity_mw->field_metadata_json->value();
  if (empty($json)) {
    // Not really an error.
    return;
  }

  // Validate the json string.
  if (json_last_error() !== JSON_ERROR_NONE) {
   $errors[$field_name][$langcode][$delta][] = array(
      'error' => 'dkan_dataset_metadata_source-json_input_not_valid',
      'message' => t("JSON Metadata not valid."),
    );
   return;
  }

  // Get the Schema. The field_metadata_schema field is required so no need to
  // check for it's existence.
  $metadata_schema = $entity_mw->field_metadata_schema->value();

  // Get the Schema file uri.
  $metadata_schema = entity_metadata_wrapper('taxonomy_term', $metadata_schema);
  $metadata_schema_file = $metadata_schema->field_metadata_json_schema_file->raw();

  if (empty($metadata_schema_file) || empty($metadata_schema_file['uri'])) {
    $errors['field_metadata_schema'][$langcode][$delta][] = array(
      'error' => 'dkan_dataset_metadata_source-missing_schema_file',
      'message' => t("@metadata_title Schema is missing JsonSchema file.",
        array('@metadata_title' => $metadata_schema->name->value(array('sanitize' => TRUE)))
      ),
    );
    return;
  }

  $metadata_schema_file_uri = $metadata_schema_file['uri'];

  // Run the json throu validation.
  $validation_errors = dkan_dataset_metadata_source_validate_jsonschema(json_decode($json, FALSE), $metadata_schema_file_uri);
  if (!empty($validation_errors)) {
    $errors[$field_name][$langcode][$delta] = $validation_errors;
  }
}

/**
 * Validate JSON string against a jsonSchema file.
 *
 * @param $json_object It expects this to be result of a json_decode.
 * @param $jsonSchema_uri The uri of the jsonSchema file, string expected.
 *
 * @return $errors Array similarly keyed to the $errors array used in
 * hook_field_attach_validate().
 */
function dkan_dataset_metadata_source_validate_jsonschema($json_object, $jsonSchema_uri) {
  $errors = array();
  libraries_load('json-schema');

  try {
    $retriever = new JsonSchema\Uri\UriRetriever;
    $schema = $retriever->retrieve($jsonSchema_uri);

    $validator = new JsonSchema\Validator();
    $validator->check($json_object, $schema);

    if (!$validator->isValid()) {
      foreach ($validator->getErrors() as $jsonschema_error) {
        $errors[] = array(
          'error' => 'dkan_dataset_metadata_source-' . $jsonschema_error['property'],
          'message' => t("@property: Error, @message.", array(
            '@property' => $jsonschema_error['property'],
            '@message' => $jsonschema_error['message'])
          ),
        );
      }
    }
  }
  catch (\Exception $exception) {
    $errors[] = array(
      'error' => 'dkan_dataset_metadata_source-validation-exception',
      'message' => 'Validation failed with exception: ' . $exception->getMessage(),
    );
  }
  return $errors;
}

/**
 * Implements hook_field_formatter_info().
 */
function dkan_dataset_metadata_source_field_formatter_info() {
  return array(
    'dkan_dataset_metadata_source_json' => array(
      'label' => t('Metadata Source JSON'),
      'field types' => array('text', 'text_long',),
    )
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function dkan_dataset_metadata_source_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  if ($display['type'] == 'dkan_dataset_metadata_source_json') {
    $entity_mw = entity_metadata_wrapper('node', $entity);

    // Get the Schema. The field_metadata_schema field is required so no need to
    // check for it's existence.
    $metadata_schema = $entity_mw->field_metadata_schema->value();

    // Get the Schema file uri.
    $metadata_schema = entity_metadata_wrapper('taxonomy_term', $metadata_schema);
    $metadata_schema_file = $metadata_schema->field_metadata_json_schema_file->raw();

    $jsonSchema_array = drupal_json_decode(file_get_contents($metadata_schema_file['uri']));

    $element = array();
    foreach ($items as $delta => $item) {
      // Construct the #pre_render array
      // TODO
      $pre_render = array();

      // Convert json string to an array;
      $item = utf8_encode($item['value']);
      $json_array = drupal_json_decode($item);

      // BUild the render array.
      $element[$delta] = array(
        // Theme
        '#theme' => 'dkan_dataset_json_schema',
        // Variables.
        '#metadata_node' => $entity,
        '#json_array' => $json_array,
        '#jsonSchema_array' => $jsonSchema_array,
        '#jsonSchema_id' => $jsonSchema_array['id'],
        // #pre_render array constructed earlier
        '#pre_render' => $pre_render,
        // Varius render array parameters.
        // TODO
        '#attributes' => array(
          'class' => array(
            'field-type-' . drupal_html_class($field['type']),
            //'field-name-' . drupal_html_class($field_name),
            'field-widget-' . drupal_html_class($instance['widget']['type']),
            ),
          ),
          // Use the weight provided by the widget, or default to 0.
          '#weight' => isset($instance['widget']['weight']) ? $instance['widget']['weight'] : '0',
      );
    }
    // We are done here.
    return $element;
  }
}
